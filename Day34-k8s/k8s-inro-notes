Docker disadvantages
================

	1. Container are very light weight 
	2. Container are not self-healing
	3. Docker will not support auto-healing becz docker know only how to create the container and docker doesn't know how to manage container
	4. Docker will not support auto-scaling -> 1. horizontal A.S:- increasing vm's or servers, 2. vertical A.S:- increasing cpu, memory , scale-up- increasing resources and scale-down - decreasing resources 
	5. Docker will not support LB


K8S-Kubernetes
============

Why k8s?
=======
1. Container are very light weight 
2. Container are not self-healing
3. Docker will not support auto-healing 
4. Docker will not support auto-scaling -> 1. horizontal A.S:- increasing vm's or servers, 2. vertical A.S:- increasing cpu, memory  
5. Docker will not support LB

Wt is k8s?
========

	Ø It is a containerization management tool:- it k8s never create any container and it will manage only the container
	Ø Also it’s a orchestration tool:- k8s has many resources or objects:- it requires one manager is called orchestration 
	Ø It is an open source platform:- it's completely free any one can use


History of k8s
===========

	Ø K8s was created by google in 2013 in Go lng
	Ø Initially k8s was not open source platform
	Ø But in 2014 google has donated k8s to CNCF(cloud native computing foundation) and its continued as an open source platform.

K8s:- is called cluster
Cluster:- is combination of nodes
Node:- is called vm

Pod:- it is a smallest deployable unit it is nothing but where we are going to managing our container is called pod

Features of k8s
=============

	1. Autoscaling:- k8s automatically scale up and scale down app resources as per the app demand:- Vertical AS:- It will crease cpu's, memory and storage, Horizontal AS:- It will increase servers.
	2. Auto healing :- 10 pods :- 2 pods got deleted :- app down time:- k8s automatically will repair ur pods or will create new pods within fraction of ms for not getting any app down time.
	3. Load balancing:- it is responsibility to distribute the users traffic between  the servers equally and k8s can manage load balancing of app very well.
	4. Platform independent:- k8s can work on any infra or any cloud  or on-premises
	5. Fault tolerance:- k8s will notify you if any node or pod fails
	6. Rollback :- you can switch to previous version ,  3.1.2  --> 3.1.3
	7. Health monitoring of containers:- k8s regularly will monitor containers health
	8. Orchestration:- it will act as manager in k8s cluster to managing entire k8s resources or objects.


Cluster
======

	Ø combination of nodes
	Ø Node is nothing but vm
	Ø Every cluster has two type nodes


	1. Master node / control plane
	2. Worker node


	1. Master node
  ==============


	Ø It is going to managing entire ur cluster and its actual state
	Ø Master node is heart of the cluster
	Ø Master node is responsible to make available workers node ( without master node u cant get any worker node)
	Ø Usually every cluster has one master and has multiple worker nodes
	Ø Master node has 4 components


	1. API server
  ===========

	Ø it is an entry point of cluster .
	Ø Whenever you run the command first request will go to the api server only
	Ø It will validate requests and updates cluster state .
	Ø All communication between components goes through api server

	1. Etcd
  =======

	Ø The entire cluster info or data is going to be stored in a etcd
	Ø It is nothing but like database for cluster
	Ø It will store ur data in the form  key-value-pair


	1. Controller manager
  ===================

	Ø It is called as kube-controller-manager
	Ø It will ensure ur cluster is always in desired state, 0 dp > 2 dp, 10 pods , 0 pods > 10 pods
	Ø Node controller, replication controller, job controller, endpoints controller 
	Ø Before creating any resource in cluster ur cluster will be in actual state from actual state to desired state , I hv desirted to create 5 pods , 5 dp .

	1. Scheduler 
  ===========

	Ø 5 wn  >  50 pods  >  10 pods > 10*5=50
	Ø It will schedule ur cluster tasks
	Ø It will decide which node a pod should run on

Worker node
===========

	Ø With the help of master node only we can create n.of wn 
	Ø Where ur app workload is going to be deployed is called wn
	Ø It will communicate with the master node
	Ø Where the actual app's run 
	Ø Wn also has 4 components 

	1. Kubelet
  =========

	Ø It is an agent on every worker node
	Ø It will communicate with api server
	Ø It will create n manage ur pods in wn

	1. Kube-proxy
  ============

	Ø It will contain entire cluster network info like node ip, pod ip , svc ip
	Ø It will implement k8s svc concept
	Ø It will maintain ip tables
	Ø It will make communicate pod to svc

3.pod 
=====

	Ø it is a smallest deployable unit it is nothing but where we are going to managing our container is called pod

	1. Container runtime
  ==================

	Ø It will run container in k8s 
	Ø K8s doesn't run container 
	Ø It will provide container env to run the container


Kubectl:- it is a command line interface tool how we are going to communicate with the cluster

Prerequisites of eks cluster in aws
============================

	1. You need a vm
	2. Iam user and generate aws access keys
	3. Install kubectl on vm: it is cli 
	4. Install eksctl on vm:- to creating cluster via cli
	5. Install aws cli on vm (before installing aws cli you must install unzip command - apt install unzip -y)
	6. Configure aws access keys on vm
	7. Create a cluster using cli

eksctl create cluster --name murali-cluster --region us-east-1  --zones us-east-1a,us-east-1b  --nodegroup-name k8s-ng  --node-type t2.medium  --nodes 2



How to create ns
==============

	Ø In a cluster whenever u want to create any resource u have follow two approaches 

	1. Imperative style:- using commands is called imperative style
    2.  Declarative style:- using yaml

Svc types
========

	1. ClusterIP:-  it will expose app within the cluster and it is for prod use and you can't access app out of the cluster and it will give only static virtual pvt ip add.
	2. NodePort: - It will expose app in a cluster on each worker node and using worker node external ip add we can able to access the app outside of the cluster but it is for temporary use,  there is a port limitations 

	Ø K8s assigns a port form 30000 to 32767 

	1. LoadBalancer:- it will expose app outside of the cluster and it will give one external ip add then you can able to access the app out of the cluster but LB will give you cost and when you don't have domain or host name but if you want to access app outside of the cluster you can use LB.

	1. ExternalName:- it will assign a domain name to ur svc so that you can access app using domain name instead ip add, flipkart.com,  amazon.com , jio.com, it is not for prod use, we will use for db end point connections 


Flipkart App
==========

	Ø My app has 10 micro svc's :- flipkart.com:- orders.flipkart.com,  wishlist.flipkrt.com
	Ø Each micro svc requires one svc in k8s
	Ø LB :- ex-ip :- it is cost
	Ø Client budget is only 25$
	Ø LB is 5$
	Ø 10*5=50$

Ingress
======
	Ø Required only one LB 
	Ø Using single LB ingress can expose n no.of svc's
	Ø One :- 5$ --> 25$-5$ = 20$ 
	Ø clusterIP type only

Host-based routing:-- flipkart.login.com,  flipkart.cart.com,  flipkart.wishlist.com 
Path-based routing:-  /login,   /cart , /wishlist,  /orders

DevSecOps --> Development + security + operations
Goal:- same as devops but with an added emphasis on security 
Focus:- integrating security  into every step of the development process instead of treating it as afterthought.

Key activities:- automated security testing, code scanning and addressing vulnerabilities early 
Tools:- same as devops with extra tools for security ex:- SonarQube, trivy etc

Core idea:- shift security left   --> make security everyone's responsibility from the beginning.

Key Difference 
============

DevOps focuses on speed and collaboration 

DevSecOps adds security as a central part of the process without scarifying speed

In short  :- DevOps = faster delivery of software  and DevSecOps = faster + security delivery of software 


To Creating a pod in k8s wt do you need?
=================================
Ø Pod name
Ø Container name
Ø Container image
Ø Container port number 

Annotations 
Name: "murali"  - key value pair

Name: - key 
Murali: value

Username: murali  - bXVyYWxp
Passwd: Murali&$%691 - TXVyYWxpJiQlNjkx

Base64:- it is nothing but the process of encoding and decoding ur values is called base64

It will not encrypt ur values but it will only encode and decode ur values 

K8s secrets will stores values in different types 

Opaque:- it is a default k8s secret type

Stateless app?
============

Ø It is nothing but does not store any data inside pod/container.
Ø App pods/containers never store any data .
Ø For this we use stateless resource in the k8s.
Ø Stateless will not keep pods names or identify constantly means it will change the names whenever you recreate or restart your deployment 

Ex:- web app, api's, backed server - application 

Deployment is for stateless in k8s

Characteristics 
============

Ø No local storage
Ø Pods are identical
Ø Can be deleted anytime
Ø Uses deployment resource
Ø Uses service - clusterIP, LB, NP,EN

Stateful app?
===============

Ø It is nothing but stateful app will store data and needs identity
Ø Pod names should be constant 
Ø It will ask headless service not like actual service
Ø If pod deletes data lost, again u have to create pod with the same name .
Ex:- database servers like mongodb, postgresql, mysql etc


I give replica count 5:- 
To creating pods it follows ascending order:-  mongo-pod-0, mongo-pod-1, mongo-pod-2, mongo-pod-3, mongo-pod-4
To deleting pods it follows descending order:- mongo-pod-4, mongo-pod-3, mongo-pod-2, mongo-pod-1, mongo-pod-0

Uses
====

Ø Stable pod name
Ø Stable storage
Ø Ordered startup
Same volume attached back

Why volumes
===========

	Ø To persisting app data
	Ø To back up the data
	Ø To access the data
	Ø To sharing the data

What is volumes
=============

	Ø A volume in k8s is a storage unit that is attached to a pod
	Ø Containers are stateless :- once restarted they lose data
	Ø A volume is mounted inside a pod and can be accessed by containers
	Ø Think of it’s a hard drive attached to ur container
	Ø Volume is a piece of storage in a cluster


Types of volumes in k8s
===================

	1. emptyDir:-  temporary storage that lasts as long as pod runs, for temporary or testing.
	2. hostPath:- it will use nodes filesystem
	3. confiMaps & Secrets:- store configuration and secrets 
	4. Pv(persistent volume) & pvc(persistent volume claim):- long-term storage from cloud or on-prem.
	5. CSI driver:- cloud provider storage (aws-ebs, GCP-PD, Azure-Disk)

Pv :- it is a storage like disk :- 20GB, cluster admin, pv is actual storage resource in k8s like disk, nfs etc

PVC:- it will request storage from pv, a request for the storage by an app

	Ø Pv ,pvc they are just k8s objects 
	Ø They don’t contain the logic to create or manage storage
	Ø CSI:- container storage interface:- it is a plugin that actually knows how to provision, attaché, delete storage in a cluster is called CSI driver. 
	Ø Without csi driver k8s can't manage or create pv's 
	Ø If u create pv manually don’t need  a csi driver becz you are going to provisioning manually 
	Ø By Ur-self attach or pointing to existing storages

Volumes are two types
===================

	1. Static volumes :- we have to create ebs volume in a cloud provider then you will get volume id after you have to create a pv to get storage from aws ebs is called static volumes. For this volumes you have to create PV AND PVC, always you have to manage manually. No need CSI driver plugin.
	2. Dynamic volumes:- you don't need to create ebs volume in a cloud provider and you don’t need to create pv for storage without having ebs volume and pv we  can get storage from the cluster is called dynamic volumes. For this volumes you just create only PVC . You don’t need to manage manually. You need to install CSI driver plugin in a cluster.

CSI driver:
========

	Ø K8s doesn't allow itself aws azure gcp API'S
	Ø So how k8s will talk to cloud storage.
	Ø CSI driver will be act as a bridge between k8s cluster and cloud storage 
	Ø It is a standard interface and it will allow k8s to talk external storage systems.
	
	

Sc is medium of communication ?:-  it will tell to k8s which csi driver to use to provision storage


Storage class:- 
============

	Ø A storage class is like a blueprint for dynamic storage in k8s
	Ø It will define how pv's should be created when a pvc asks  for storage 
	Ø Instead of creating pv manually , the sc tells k8s to talk to the underling cloud or storage provider and provision the storage automatically 

	Ø Without sc you need to create pv manually 
	Ø If ur app needs storage , you must check whether if pv is available 


Static volumes:- physical storage (ebs)  --> PV --> PVC --> pod 
Dynamic volumes:- SC(pv) -->  PVC --> POD